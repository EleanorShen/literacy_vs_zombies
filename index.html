<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>è¯†å­—å¤§æˆ˜åƒµå°¸ - æ™ºèƒ½å¤ä¹ ç‰ˆ</title>
    <style>
        :root {
            --lawn-green: #2ecc71;
            --lawn-dark: #27ae60;
            --ui-bg: #8B4513;
            --quiz-bg: #fdf5e6;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: "Microsoft YaHei", sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: #222;
            user-select: none;
        }

        /* --- 1. é¡¶éƒ¨ï¼šé“å…·æ  --- */
        #top-bar {
            height: 80px;
            background: var(--ui-bg);
            display: flex;
            align-items: center;
            padding: 0 40px;
            color: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 20;
            flex-shrink: 0;
            justify-content: center;
            position: relative;
        }

        .score-box {
            background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 5px;
            font-size: 24px; margin-right: 40px; border: 2px solid #ffd700; min-width: 140px;
            display: flex; align-items: center; gap: 10px;
        }

        .timer-box { font-size: 20px; margin-right: 40px; color: #ddd; display: flex; align-items: center; gap: 10px; }

        .card {
            width: 70px; height: 80px; background: #eee; border-radius: 5px; margin-right: 15px;
            cursor: pointer; display: flex; flex-direction: column; align-items: center;
            justify-content: center; position: relative; border: 2px solid #444;
            transition: transform 0.1s; overflow: hidden;
        }
        .card.selected { border-color: yellow; box-shadow: 0 0 15px yellow; transform: scale(1.1); }
        .card.disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(100%); }
        .card-cost { position: absolute; bottom: 2px; right: 2px; font-size: 14px; color: black; font-weight: bold; z-index: 2; text-shadow: 1px 1px 0 #fff;}
        .card img { width: 50px; height: 50px; object-fit: contain; }

        /* ç»“æŸæ¸¸æˆæŒ‰é’® */
        .end-btn {
            position: absolute; right: 20px;
            background: #c0392b; color: white; border: 2px solid #e74c3c;
            padding: 10px 20px; font-size: 18px; font-weight: bold; border-radius: 8px;
            cursor: pointer; box-shadow: 0 4px 0 #922b21;
        }
        .end-btn:active { transform: translateY(4px); box-shadow: none; }

        /* --- 2. ä¸­é—´ï¼šæ¸¸æˆåŒº (è‰åª) --- */
        #game-wrapper {
            flex: 0 0 500px;
            width: 100%;
            background: #333;
            display: flex;
            justify-content: center;
            position: relative;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }

        #lawn {
            width: 900px;
            height: 500px;
            position: relative;
            overflow: hidden;
            background-image:
                linear-gradient(var(--lawn-dark) 2px, transparent 2px),
                linear-gradient(90deg, var(--lawn-dark) 2px, transparent 2px);
            background-size: 100px 100px;
            background-color: var(--lawn-green);
            cursor: crosshair;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* å®ä½“é€šç”¨ */
        .entity {
            position: absolute; width: 80px; height: 80px; display: flex;
            align-items: center; justify-content: center; z-index: 2; pointer-events: none;
            flex-direction: column; justify-content: flex-end; padding-bottom: 5px;
        }
        .entity img { width: 100%; height: 100%; object-fit: contain; filter: drop-shadow(2px 4px 4px rgba(0,0,0,0.4)); }
        .plant { z-index: 3; }
        .zombie { z-index: 4; transition: left 0.1s linear; }

        .zombie-accessory {
            position: absolute; top: -15px; left: 20px;
            font-size: 40px; z-index: 5;
            filter: drop-shadow(1px 2px 2px rgba(0,0,0,0.5));
        }

        .hp-bar-bg { position: absolute; top: -10px; width: 60px; height: 6px; background: #555; border-radius: 3px; overflow: hidden; z-index: 10;}
        .hp-bar-fill { height: 100%; width: 100%; transition: width 0.2s; }
        .hp-red { background: #e74c3c; }
        .hp-green { background: #2ecc71; }

        .bullet {
            position: absolute; width: 20px; height: 20px; background: #0f0;
            border-radius: 50%; z-index: 2; box-shadow: 0 0 5px #fff; border: 1px solid #006400;
        }

        #wave-message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 60px; color: #ff3333; font-weight: bold;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #000;
            z-index: 50; display: none; pointer-events: none; white-space: nowrap;
            background: rgba(0,0,0,0.6); padding: 20px 40px; border-radius: 10px; border: 4px solid #fff;
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } to { transform: translate(-50%, -50%) scale(1); opacity: 1; } }

        /* --- 3. åº•éƒ¨ï¼šè¯†å­—æŒ‘æˆ˜åŒº --- */
        #quiz-panel {
            flex: 1;
            background: var(--quiz-bg);
            border-top: 5px solid #5d4037;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            padding: 10px 40px;
            box-sizing: border-box;
            gap: 40px;
            position: relative;
        }

        .quiz-group-left { display: flex; flex-direction: column; align-items: flex-start; justify-content: center; width: 200px; }
        .quiz-group-center { display: flex; flex-direction: row; align-items: center; gap: 20px; }
        .quiz-group-right { flex: 1; max-width: 600px; }

        .quiz-type-label { font-size: 18px; color: #888; margin-bottom: 5px; }
        .quiz-title { font-size: 28px; color: #5d4037; font-weight: bold; margin: 0; }
        .feedback-area { font-size: 20px; font-weight: bold; margin-top: 10px; height: 30px; }
        .correct { color: green; }

        .main-display {
            font-size: 70px; color: #d35400; font-weight: bold;
            background: #fff; padding: 10px 30px; border-radius: 15px;
            box-shadow: 0 4px 0 #ddd; min-width: 140px; text-align: center;
            font-family: "KaiTi", "æ¥·ä½“", serif;
        }

        .main-speaker-btn {
            font-size: 40px; cursor: pointer; background: #ffecb3; border: 3px solid #ffa000;
            border-radius: 50%; width: 80px; height: 80px; display: flex;
            align-items: center; justify-content: center; box-shadow: 0 4px 0 #ffa000;
            transition: transform 0.1s;
        }
        .main-speaker-btn:active { transform: scale(0.95); box-shadow: none; }

        .options-container { width: 100%; }

        .char-grid, .pinyin-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 15px;
        }

        .option-btn-char {
            background: #3498db; color: white; border: none; padding: 0; font-size: 36px;
            border-radius: 10px; cursor: pointer; box-shadow: 0 5px 0 #2980b9;
            font-family: "KaiTi", "æ¥·ä½“", serif; height: 70px;
        }
        .option-btn-char:active { transform: translateY(4px); box-shadow: none; }

        .pinyin-option-row { display: flex; gap: 8px; }
        .option-btn-pinyin {
            flex: 1;
            background: #9b59b6; color: white; border: none; height: 60px; font-size: 26px;
            border-radius: 10px; cursor: pointer; box-shadow: 0 4px 0 #8e44ad; font-weight: bold;
        }
        .option-btn-pinyin:active { transform: translateY(4px); box-shadow: none; }

        .small-speaker {
            width: 50px; height: 60px; background: #f1c40f; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; font-size: 24px; border-bottom: 4px solid #d35400; color: #333;
        }
        .small-speaker:active { transform: translateY(4px); border-bottom: none; }

        #wrong-overlay {
            position: absolute; top:0; left:0; right:0; bottom:0;
            background: rgba(255,255,255,0.8); display: flex; justify-content: center; align-items: center;
            z-index: 100; pointer-events: none; opacity: 0; transition: opacity 0.2s;
        }
        #wrong-mark { font-size: 200px; color: red; font-weight: bold; transform: scale(0.5); transition: transform 0.2s; }
        .show-wrong { opacity: 1 !important; }
        .show-wrong #wrong-mark { transform: scale(1) !important; }

        /* æ¸¸æˆç»“æŸ/å¼€å§‹é®ç½© */
        #game-over, #start-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95); display: flex; justify-content: center;
            align-items: center; flex-direction: column; z-index: 200; color: white;
            padding: 20px;
        }
        #game-over { display: none; } /* åˆå§‹éšè— */

        .game-over-title { font-size: 50px; margin-bottom: 20px; font-weight: bold; color: #e74c3c; }
        .game-stats { font-size: 24px; margin-bottom: 20px; color: #f1c40f; }

        .review-box {
            background: rgba(255,255,255,0.1); width: 80%; max-width: 600px;
            border-radius: 10px; padding: 20px; margin-bottom: 30px;
            max-height: 200px; overflow-y: auto; text-align: center;
        }
        .review-title { color: #aaa; font-size: 16px; margin-bottom: 10px; border-bottom: 1px solid #555; padding-bottom: 5px; }
        .review-item {
            display: inline-block; background: #eee; color: #333;
            padding: 5px 15px; margin: 5px; border-radius: 20px; font-size: 20px;
            font-family: "KaiTi", "æ¥·ä½“", serif;
        }

        .start-btn {
            font-size: 30px; padding: 20px 60px;
            cursor: pointer; background: #fff; border: none; border-radius: 60px;
            font-weight: bold; color: #333; transition: transform 0.2s;
        }
        .start-btn:hover { transform: scale(1.05); }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h1>è¯†å­—å¤§æˆ˜åƒµå°¸ (å¤ä¹ ç‰ˆ)</h1>
        <p>ğŸ‘‚ å¬éŸ³é€‰å­— & ğŸ‘ï¸ çœ‹å­—é€‰æ‹¼éŸ³</p>
        <p style="font-size:18px; color:#aaa;">(è¯·ç¡®ä¿ peashooter.png å’Œ zombie.png å·²å°±ä½)</p>
        <button class="start-btn" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
    </div>

    <!-- é¡¶éƒ¨ -->
    <div id="top-bar">
        <div class="score-box">â˜€ï¸ <span id="score">0</span></div>
        <div class="timer-box">â±ï¸ <span id="game-time">00:00</span></div>
        <div class="card" id="card-peashooter" onclick="selectPlant('peashooter', 100)">
            <img src="peashooter.png" alt="Pea" onerror="this.style.display='none';this.parentNode.innerText='ğŸŒ±'">
            <div class="card-cost">100</div>
        </div>
        <div style="margin-left: 20px; font-size: 14px; opacity: 0.8;">
            è±Œè±†ä¼¤å®³: 25 | æ”»é€Ÿ: 1.4ç§’
        </div>
        <!-- ç»“æŸæŒ‰é’® -->
        <button class="end-btn" onclick="handleGameOver('manual')">ğŸ›‘ ç»“æŸæ¸¸æˆ</button>
    </div>

    <!-- æ¸¸æˆåŒº -->
    <div id="game-wrapper">
        <div id="wave-message">ğŸ’€ åˆä¸€æ³¢åƒµå°¸æ¥äº†ï¼</div>
        <div id="lawn"></div>

        <!-- æ¸¸æˆç»“æŸé¢æ¿ (å¤ç”¨) -->
        <div id="game-over">
            <div class="game-over-title" id="go-title">æ¸¸æˆç»“æŸ</div>
            <div class="game-stats" id="go-stats">ç­”å¯¹: 0</div>

            <div class="review-box">
                <div class="review-title">é”™é¢˜æœ¬ (æœ¬æ¬¡åšé”™çš„å­—)</div>
                <div id="go-review-list" style="color: #fff;">
                    <!-- åŠ¨æ€æ’å…¥é”™é¢˜ -->
                </div>
            </div>

            <button class="start-btn" onclick="location.reload()">é‡æ–°æŒ‘æˆ˜</button>
        </div>
    </div>

    <!-- ç­”é¢˜åŒº -->
    <div id="quiz-panel">
        <div id="wrong-overlay"><div id="wrong-mark">âŒ</div></div>

        <div class="quiz-group-left">
            <div class="quiz-type-label" id="quiz-mode-label">æ¨¡å¼åŠ è½½ä¸­...</div>
            <div class="quiz-title" id="quiz-title">é¢˜ç›®è¦æ±‚</div>
            <div class="feedback-area" id="feedback"></div>
        </div>

        <div class="quiz-group-center">
            <div class="main-display" id="main-display">?</div>
            <div class="main-speaker-btn" id="main-speaker" onclick="speakQuestion()" title="æ’­æ”¾è¯»éŸ³">ğŸ”Š</div>
        </div>

        <div class="quiz-group-right">
            <div class="options-container" id="options-container"></div>
            <div style="text-align: right; margin-top: 5px; color: #888;">ç­”å¯¹ +30 / ç­”é”™ -10</div>
        </div>
    </div>

    <script>
        // --- 1. æ•°æ®é…ç½® ---
        const wordData = [
          {char: 'å¤©', pinyin: 'tiÄn'}, {char: 'åœ°', pinyin: 'dÃ¬'}, {char: 'äºº', pinyin: 'rÃ©n'},
          {char: 'ä½ ', pinyin: 'nÇ'}, {char: 'æˆ‘', pinyin: 'wÇ’'}, {char: 'ä»–', pinyin: 'tÄ'},
          {char: 'ä¹Ÿ', pinyin: 'yÄ›'}, {char: 'å£', pinyin: 'kÇ’u'}, {char: 'è€³', pinyin: 'Ä›r'},
          {char: 'ç›®', pinyin: 'mÃ¹'}, {char: 'ç¦¾', pinyin: 'hÃ©'}, {char: 'ä¸‹', pinyin: 'xiÃ '},
          {char: 'æ‰‹', pinyin: 'shÇ’u'}, {char: 'è¶³', pinyin: 'zÃº'}, {char: 'ç«™', pinyin: 'zhÃ n'},
          {char: 'å', pinyin: 'zuÃ²'}, {char: 'æ—¥', pinyin: 'rÃ¬'}, {char: 'æœˆ', pinyin: 'yuÃ¨'},
          {char: 'æ°´', pinyin: 'shuÇ'}, {char: 'ç«', pinyin: 'huÇ’'}, {char: 'å±±', pinyin: 'shÄn'},
          {char: 'çŸ³', pinyin: 'shÃ­'}, {char: 'ç”°', pinyin: 'tiÃ¡n'}, {char: 'å¯¹', pinyin: 'duÃ¬'},
          {char: 'äº‘', pinyin: 'yÃºn'}, {char: 'é›¨', pinyin: 'yÇ”'}, {char: 'é£', pinyin: 'fÄ“ng'},
          {char: 'èŠ±', pinyin: 'huÄ'}, {char: 'é¸Ÿ', pinyin: 'niÇo'}, {char: 'è™«', pinyin: 'chÃ³ng'},
          {char: 'çˆ¸', pinyin: 'bÃ '}, {char: 'å¦ˆ', pinyin: 'mÄ'}, {char: 'æ£‹', pinyin: 'qÃ­'},
          {char: 'é¸¡', pinyin: 'jÄ«'}, {char: 'é©¬', pinyin: 'mÇ'}, {char: 'åœŸ', pinyin: 'tÇ”'},
          {char: 'ä¸', pinyin: 'bÃ¹'}, {char: 'å­—', pinyin: 'zÃ¬'}, {char: 'è¯', pinyin: 'cÃ­'},
          {char: 'è¯­', pinyin: 'yÇ’'}, {char: 'å¥', pinyin: 'jÃ¹'}, {char: 'ç”»', pinyin: 'huÃ '},
          {char: 'æ‰“', pinyin: 'dÇ'}, {char: 'æ¡Œ', pinyin: 'zhuÅ'}, {char: 'çº¸', pinyin: 'zhÇ'},
          {char: 'æ–‡', pinyin: 'wÃ©n'}, {char: 'æ•°', pinyin: 'shÃ¹'}, {char: 'å­¦', pinyin: 'xuÃ©'},
          {char: 'éŸ³', pinyin: 'yÄ«n'}, {char: 'ä¹', pinyin: 'lÃ¨'}, {char: 'å¦¹', pinyin: 'mÃ¨i'},
          {char: 'å¥¶', pinyin: 'nÇi'}, {char: 'ç™½', pinyin: 'bÃ¡i'}, {char: 'çš®', pinyin: 'pÃ­'},
          {char: 'è‰', pinyin: 'cÇo'}, {char: 'å®¶', pinyin: 'jiÄ'}, {char: 'æ˜¯', pinyin: 'shÃ¬'},
          {char: 'å°', pinyin: 'xiÇo'}, {char: 'æ¡¥', pinyin: 'qiÃ¡o'}, {char: 'å°', pinyin: 'tÃ¡i'},
          {char: 'è½¦', pinyin: 'chÄ“'}, {char: 'ç¾Š', pinyin: 'yÃ¡ng'}, {char: 'èµ°', pinyin: 'zÇ’u'},
          {char: 'é›ª', pinyin: 'xuÄ›'}, {char: 'å„¿', pinyin: 'Ã©r'}, {char: 'ç§‹', pinyin: 'qiÅ«'},
          {char: 'æ°”', pinyin: 'qÃ¬'}, {char: 'äº†', pinyin: 'le'}, {char: 'æ ‘', pinyin: 'shÃ¹'},
          {char: 'å¶', pinyin: 'yÃ¨'}, {char: 'ç‰‡', pinyin: 'piÃ n'}, {char: 'å¤§', pinyin: 'dÃ '},
          {char: 'é£', pinyin: 'fÄ“i'}, {char: 'ä¼š', pinyin: 'huÃ¬'}, {char: 'ä¸ª', pinyin: 'gÃ¨'},
          {char: 'çš„', pinyin: 'de'}, {char: 'èˆ¹', pinyin: 'chuÃ¡n'}, {char: 'ä¸¤', pinyin: 'liÇng'},
          {char: 'å¤´', pinyin: 'tÃ³u'}, {char: 'åœ¨', pinyin: 'zÃ i'}, {char: 'é‡Œ', pinyin: 'lÇ'},
          {char: 'çœ‹', pinyin: 'kÃ n'}, {char: 'è§', pinyin: 'jiÃ n'}, {char: 'é—ª', pinyin: 'shÇn'},
          {char: 'æ˜Ÿ', pinyin: 'xÄ«ng'}, {char: 'æ±Ÿ', pinyin: 'jiÄng'}, {char: 'å—', pinyin: 'nÃ¡n'},
          {char: 'å¯', pinyin: 'kÄ›'}, {char: 'é‡‡', pinyin: 'cÇi'}, {char: 'è²', pinyin: 'liÃ¡n'},
          {char: 'é±¼', pinyin: 'yÃº'}, {char: 'ä¸œ', pinyin: 'dÅng'}, {char: 'è¥¿', pinyin: 'xÄ«'},
          {char: 'åŒ—', pinyin: 'bÄ›i'}, {char: 'å°–', pinyin: 'jiÄn'}, {char: 'è¯´', pinyin: 'shuÅ'},
          {char: 'æ˜¥', pinyin: 'chÅ«n'}, {char: 'é’', pinyin: 'qÄ«ng'}, {char: 'è›™', pinyin: 'wÄ'},
          {char: 'å¤', pinyin: 'xiÃ '}, {char: 'å¼¯', pinyin: 'wÄn'}, {char: 'å°±', pinyin: 'jiÃ¹'},
          {char: 'å†¬', pinyin: 'dÅng'}, {char: 'ç”·', pinyin: 'nÃ¡n'}, {char: 'å¥³', pinyin: 'nÇš'},
          {char: 'å¼€', pinyin: 'kÄi'}, {char: 'å…³', pinyin: 'guÄn'}, {char: 'æ­£', pinyin: 'zhÃ¨ng'},
          {char: 'å', pinyin: 'fÇn'}, {char: 'è¿œ', pinyin: 'yuÇn'}, {char: 'æœ‰', pinyin: 'yÇ’u'},
          {char: 'è‰²', pinyin: 'sÃ¨'}, {char: 'è¿‘', pinyin: 'jÃ¬n'}, {char: 'å¬', pinyin: 'tÄ«ng'},
          {char: 'æ— ', pinyin: 'wÃº'}, {char: 'å£°', pinyin: 'shÄ“ng'}, {char: 'å»', pinyin: 'qÃ¹'},
          {char: 'è¿˜', pinyin: 'hÃ¡i'}, {char: 'æ¥', pinyin: 'lÃ¡i'}, {char: 'å¤š', pinyin: 'duÅ'},
          {char: 'å°‘', pinyin: 'shÇo'}, {char: 'é»„', pinyin: 'huÃ¡ng'}, {char: 'ç‰›', pinyin: 'niÃº'},
          {char: 'åª', pinyin: 'zhÄ«'}, {char: 'çŒ«', pinyin: 'mÄo'}, {char: 'è¾¹', pinyin: 'biÄn'},
          {char: 'é¸­', pinyin: 'yÄ'}, {char: 'æœ', pinyin: 'guÇ’'}, {char: 'è‹¹', pinyin: 'pÃ­ng'},
          {char: 'æ', pinyin: 'xÃ¬ng'},
          {char: 'æ¡ƒ', pinyin: 'tÃ¡o'}, {char: 'ä¹¦', pinyin: 'shÅ«'}
        ];

        const ZOMBIE_TYPES = {
            NORMAL: { type: 'normal', hp: 150, speed: 0.4, accessory: null, damage: 0.5 },
            CONE:   { type: 'cone',   hp: 400, speed: 0.35, accessory: 'ğŸ”º', damage: 0.8 },
            BUCKET: { type: 'bucket', hp: 900, speed: 0.3,  accessory: 'ğŸª£', damage: 1.0 }
        };

        const state = {
            score: 0,
            selectedPlant: null,
            gridSize: 100,
            rows: 5,
            cols: 9,
            plants: [],
            zombies: [],
            bullets: [],
            isGameOver: false,
            isGameStarted: false,
            startTime: 0,
            lastZombieSpawn: 0,
            waveLevel: 0,
            // ç»Ÿè®¡æ•°æ®
            correctCount: 0,
            wrongAnswers: [] // å­˜å‚¨ {char, pinyin} å¯¹è±¡
        };

        const elScore = document.getElementById('score');
        const elTime = document.getElementById('game-time');
        const elLawn = document.getElementById('lawn');
        const elCardPea = document.getElementById('card-peashooter');
        const elWaveMsg = document.getElementById('wave-message');
        const synth = window.speechSynthesis;

        // è¯†å­—DOM
        const elQuizLabel = document.getElementById('quiz-mode-label');
        const elQuizTitle = document.getElementById('quiz-title');
        const elMainDisplay = document.getElementById('main-display');
        const elMainSpeaker = document.getElementById('main-speaker');
        const elOptionsContainer = document.getElementById('options-container');
        const elFeedback = document.getElementById('feedback');
        const elWrongOverlay = document.getElementById('wrong-overlay');

        // æ¸¸æˆç»“æŸDOM
        const elGameOverPanel = document.getElementById('game-over');
        const elGoTitle = document.getElementById('go-title');
        const elGoStats = document.getElementById('go-stats');
        const elGoReviewList = document.getElementById('go-review-list');

        // --- 2. æ ¸å¿ƒæ¸¸æˆé€»è¾‘ ---

        function startGame() {
            document.getElementById('start-overlay').style.display = 'none';
            state.isGameStarted = true;
            state.startTime = Date.now();
            initQuiz();
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function handleGameOver(reason) {
            if (state.isGameOver) return; // é˜²æ­¢é‡å¤è§¦å‘
            state.isGameOver = true;
            elGameOverPanel.style.display = 'flex';

            let speakStr = "";

            if (reason === 'zombie') {
                elGoTitle.innerText = "ğŸ§  è„‘å­è¢«åƒæ‰äº†!";
                speakStr += "å“å‘€ï¼Œæ¸¸æˆå¤±è´¥ã€‚";
            } else {
                elGoTitle.innerText = "ğŸ‰ æŒ‘æˆ˜ç»“æŸ";
                elGoTitle.style.color = "#2ecc71";
                speakStr += "æ¸¸æˆç»“æŸã€‚";
            }

            // æ›´æ–°ç»Ÿè®¡æ•°æ®
            elGoStats.innerText = `æœ¬æ¬¡ç­”å¯¹: ${state.correctCount} é¢˜`;
            speakStr += `ä½ ä¸€å…±ç­”å¯¹äº† ${state.correctCount} é“é¢˜ã€‚`;

            // æ›´æ–°é”™é¢˜åˆ—è¡¨
            elGoReviewList.innerHTML = '';

            // å»é‡ï¼Œé˜²æ­¢åŒä¸€ä¸ªå­—åšé”™å¤šæ¬¡
            const uniqueWrongs = [];
            const map = new Map();
            for (const item of state.wrongAnswers) {
                if(!map.has(item.char)){
                    map.set(item.char, true);
                    uniqueWrongs.push(item);
                }
            }

            if (uniqueWrongs.length === 0) {
                elGoReviewList.innerHTML = '<div style="color:#aaa; padding:20px;">å¤ªæ£’äº†ï¼æ²¡æœ‰åšé”™ä»»ä½•é¢˜ç›®ï¼</div>';
                speakStr += "å¤ªæ£’äº†ï¼Œä½ æ²¡æœ‰ç­”é”™ä»»ä½•é¢˜ç›®ï¼";
            } else {
                let wrongWordsStr = "";
                uniqueWrongs.forEach(w => {
                    const div = document.createElement('div');
                    div.className = 'review-item';
                    div.innerText = `${w.char} (${w.pinyin})`;
                    elGoReviewList.appendChild(div);
                    wrongWordsStr += w.char + "ï¼Œ";
                });
                speakStr += "ä»¥ä¸‹è¿™äº›å­—ç­”é”™äº†ï¼Œè¯·æ³¨æ„å¤ä¹ ï¼š" + wrongWordsStr;
            }

            // æ’­æ”¾è¯­éŸ³æ€»ç»“
            setTimeout(() => {
                speakText(speakStr);
            }, 500);
        }

        // --- 3. è¯†å­—é¢˜åº“ç³»ç»Ÿ ---
        let currentQuestion = null;
        let isProcessing = false;

        function initQuiz() { generateQuestion(); }

        function generateQuestion() {
            if (state.isGameOver) return;
            isProcessing = false;
            const mode = Math.random() > 0.5 ? 'LISTEN' : 'READ';

            const targetIndex = Math.floor(Math.random() * wordData.length);
            const target = wordData[targetIndex];

            let distractors = [];
            while(distractors.length < 3) {
                let r = Math.floor(Math.random() * wordData.length);
                if(r !== targetIndex && !distractors.includes(wordData[r])) distractors.push(wordData[r]);
            }

            let options = [...distractors, target];
            options.sort(() => Math.random() - 0.5);

            currentQuestion = { mode: mode, target: target, options: options };

            renderQuiz();

            if (mode === 'LISTEN') {
                setTimeout(speakQuestion, 300);
            }
        }

        function speakText(text) {
            synth.cancel();
            const utterThis = new SpeechSynthesisUtterance(text);
            utterThis.lang = 'zh-CN';
            utterThis.rate = 0.8;
            synth.speak(utterThis);
        }

        function speakQuestion() {
            if (!currentQuestion || state.isGameOver) return;
            speakText(currentQuestion.target.char);
        }

        function renderQuiz() {
            elOptionsContainer.innerHTML = '';
            elFeedback.innerText = '';
            elFeedback.className = 'feedback-area';

            const q = currentQuestion;

            if (q.mode === 'LISTEN') {
                elQuizLabel.innerText = "æ¨¡å¼ï¼šğŸ‘‚ å¬éŸ³è¾¨å­—";
                elQuizTitle.innerText = "è¿™ä¸ªéŸ³å¯¹åº”å“ªä¸ªå­—ï¼Ÿ";
                elMainDisplay.innerText = q.target.pinyin;
                elMainSpeaker.style.visibility = 'visible';

                const grid = document.createElement('div');
                grid.className = 'char-grid';
                q.options.forEach(opt => {
                    const btn = document.createElement('button');
                    btn.className = 'option-btn-char';
                    btn.innerText = opt.char;
                    btn.onclick = () => checkAnswer(opt);
                    grid.appendChild(btn);
                });
                elOptionsContainer.appendChild(grid);

            } else {
                elQuizLabel.innerText = "æ¨¡å¼ï¼šğŸ‘ï¸ çœ‹å­—é€‰éŸ³";
                elQuizTitle.innerText = "è¿™ä¸ªå­—çš„æ‹¼éŸ³æ˜¯ï¼Ÿ";
                elMainDisplay.innerText = q.target.char;
                elMainSpeaker.style.visibility = 'hidden'; // çœ‹å­—æ¨¡å¼ä¸è®¸è¯»

                const grid = document.createElement('div');
                grid.className = 'pinyin-grid';
                q.options.forEach(opt => {
                    const row = document.createElement('div');
                    row.className = 'pinyin-option-row';
                    const btn = document.createElement('button');
                    btn.className = 'option-btn-pinyin';
                    btn.innerText = opt.pinyin;
                    btn.onclick = () => checkAnswer(opt);
                    const spk = document.createElement('div');
                    spk.className = 'small-speaker';
                    spk.innerText = 'ğŸ”Š';
                    spk.onclick = (e) => { e.stopPropagation(); speakText(opt.char); };
                    row.appendChild(btn);
                    row.appendChild(spk);
                    grid.appendChild(row);
                });
                elOptionsContainer.appendChild(grid);
            }
        }

        function checkAnswer(selected) {
            if (isProcessing || state.isGameOver) return;

            if (selected === currentQuestion.target) {
                // ç­”å¯¹é€»è¾‘
                elFeedback.innerText = "ç­”å¯¹äº†ï¼+30 é˜³å…‰";
                elFeedback.className = "feedback-area correct";
                addScore(30);
                state.correctCount++; // è®°å½•ç­”å¯¹æ•°
                isProcessing = true;
                setTimeout(generateQuestion, 800);
            } else {
                // ç­”é”™é€»è¾‘
                addScore(-10);
                state.wrongAnswers.push(currentQuestion.target); // è®°å½•é”™é¢˜
                showWrongAnimation();
                elFeedback.innerText = "ä¸å¯¹å“¦ï¼Œå†è¯•ä¸€æ¬¡ï¼(-10)";
                elFeedback.style.color = "red";
            }
        }

        function showWrongAnimation() {
            elWrongOverlay.classList.add('show-wrong');
            setTimeout(() => {
                elWrongOverlay.classList.remove('show-wrong');
            }, 600);
        }

        // --- 4. ç»æµä¸æ“ä½œ ---
        function addScore(n) {
            state.score += n;
            if (state.score < 0) state.score = 0;
            updateUI();
        }
        function updateUI() {
            elScore.innerText = state.score;
            if (state.score >= 100) elCardPea.classList.remove('disabled');
            else elCardPea.classList.add('disabled');
        }
        function selectPlant(type, cost) {
            if (state.score < cost) return;
            if (state.selectedPlant && state.selectedPlant.type === type) {
                state.selectedPlant = null;
                elCardPea.classList.remove('selected');
            } else {
                state.selectedPlant = { type, cost };
                elCardPea.classList.add('selected');
            }
        }
        elLawn.addEventListener('click', (e) => {
            if (!state.selectedPlant || state.isGameOver) return;
            const rect = elLawn.getBoundingClientRect();
            const col = Math.floor((e.clientX - rect.left) / state.gridSize);
            const row = Math.floor((e.clientY - rect.top) / state.gridSize);
            if (col < 0 || col >= state.cols || row < 0 || row >= state.rows) return;

            const exists = state.plants.find(p => p.row === row && p.col === col);
            if (exists) return;

            addScore(-state.selectedPlant.cost);
            createPlant(row, col, state.selectedPlant.type);
            state.selectedPlant = null;
            elCardPea.classList.remove('selected');
        });

        // --- 5. æ¸¸æˆå®ä½“é€»è¾‘ ---
        function createHPBar(colorClass) {
            const bg = document.createElement('div');
            bg.className = 'hp-bar-bg';
            const fill = document.createElement('div');
            fill.className = 'hp-bar-fill ' + colorClass;
            bg.appendChild(fill);
            return { bg, fill };
        }

        function createPlant(row, col, type) {
            const el = document.createElement('div');
            el.className = 'entity plant';
            const hpObj = createHPBar('hp-green');
            el.appendChild(hpObj.bg);

            const img = document.createElement('img');
            img.src = 'peashooter.png';
            img.onerror = () => { img.style.display='none'; el.innerText = 'ğŸŒ±'; }

            el.appendChild(img);
            el.style.left = (col * state.gridSize + 10) + 'px';
            el.style.top = (row * state.gridSize + 10) + 'px';
            elLawn.appendChild(el);
            state.plants.push({ id: Math.random(), row, col, type, el, hpBar: hpObj.fill, maxHp: 100, hp: 100, lastShot: 0 });
        }

        function determineZombieType(elapsedTime) {
            const minutes = elapsedTime / 60000;
            if (minutes >= 4 && Math.random() < 0.4) return ZOMBIE_TYPES.BUCKET;
            if (minutes >= 2 && Math.random() < 0.5) return ZOMBIE_TYPES.CONE;
            return ZOMBIE_TYPES.NORMAL;
        }

        function showWaveMessage(msg) {
            elWaveMsg.innerText = msg;
            elWaveMsg.style.display = 'block';
            setTimeout(() => {
                elWaveMsg.style.display = 'none';
            }, 2000);
        }

        function spawnZombie() {
            if(state.isGameOver) return;
            const row = Math.floor(Math.random() * state.rows);
            const elapsed = Date.now() - state.startTime;
            const typeConfig = determineZombieType(elapsed);
            const el = document.createElement('div');
            el.className = 'entity zombie';
            const hpObj = createHPBar('hp-red');
            el.appendChild(hpObj.bg);

            if (typeConfig.accessory) {
                const acc = document.createElement('div');
                acc.className = 'zombie-accessory';
                acc.innerText = typeConfig.accessory;
                el.appendChild(acc);
            }

            const img = document.createElement('img');
            img.src = 'zombie.png';
            img.onerror = () => { img.style.display='none'; const s = document.createElement('span'); s.innerText='ğŸ§Ÿ'; el.appendChild(s); }

            el.appendChild(img);

            let posX = state.cols * state.gridSize;
            el.style.left = posX + 'px';
            el.style.top = (row * state.gridSize + 10) + 'px';
            elLawn.appendChild(el);
            state.zombies.push({
                id: Math.random(), row: row, x: posX, maxHp: typeConfig.hp, hp: typeConfig.hp,
                speed: typeConfig.speed, damage: typeConfig.damage, el: el, hpBar: hpObj.fill,
                isEating: false, targetPlantId: null
            });
        }

        function fireBullet(plant) {
            const el = document.createElement('div');
            el.className = 'bullet';
            let startX = plant.col * state.gridSize + 60;
            el.style.left = startX + 'px';
            el.style.top = (plant.row * state.gridSize + 40) + 'px';
            elLawn.appendChild(el);
            state.bullets.push({ id: Math.random(), row: plant.row, x: startX, el: el, speed: 5, damage: 25 });
        }

        function gameLoop(timestamp) {
            if (!state.isGameStarted || state.isGameOver) return;
            const elapsed = Date.now() - state.startTime;
            const mins = Math.floor(elapsed / 60000);
            const secs = Math.floor((elapsed % 60000) / 1000);
            elTime.innerText = `${mins.toString().padStart(2,0)}:${secs.toString().padStart(2,0)}`;

            // Wave Logic
            const minVal = elapsed / 60000;
            let currentWave = 0;
            if (minVal >= 4) currentWave = 2;
            else if (minVal >= 2) currentWave = 1;

            if (currentWave > state.waveLevel) {
                state.waveLevel = currentWave;
                showWaveMessage("ğŸ’€ åˆä¸€æ³¢åƒµå°¸æ¥äº†ï¼");
            }

            // Spawn Logic
            let currentSpawnRate = Math.max(1000, 4000 - (elapsed / 1000) * 10);
            if (Date.now() - state.lastZombieSpawn > currentSpawnRate) {
                spawnZombie();
                state.lastZombieSpawn = Date.now();
            }

            // Plants Logic
            state.plants.forEach(plant => {
                const hasTarget = state.zombies.some(z => z.row === plant.row && z.x > plant.col * state.gridSize);
                if (hasTarget && Date.now() - plant.lastShot > 1400) {
                    fireBullet(plant);
                    plant.lastShot = Date.now();
                }
            });

            // Bullets Logic
            for (let i = state.bullets.length - 1; i >= 0; i--) {
                let b = state.bullets[i];
                b.x += b.speed;
                b.el.style.left = b.x + 'px';
                if (b.x > state.cols * state.gridSize) {
                    b.el.remove(); state.bullets.splice(i, 1); continue;
                }
                for (let j = state.zombies.length - 1; j >= 0; j--) {
                    let z = state.zombies[j];
                    if (b.row === z.row && b.x >= z.x + 10 && b.x <= z.x + 60) {
                        z.hp -= b.damage;
                        z.hpBar.style.width = Math.max(0, (z.hp / z.maxHp) * 100) + '%';
                        b.el.remove(); state.bullets.splice(i, 1);
                        if (z.hp <= 0) {
                            z.el.innerHTML = '<span style="font-size:80px">ğŸ’¥</span>';
                            setTimeout(() => z.el.remove(), 200);
                            state.zombies.splice(j, 1);
                        }
                        break;
                    }
                }
            }

            // Zombies Logic
            for (let i = state.zombies.length - 1; i >= 0; i--) {
                let z = state.zombies[i];
                if (z.isEating) {
                    const plant = state.plants.find(p => p.id === z.targetPlantId);
                    if (plant) {
                        plant.hp -= z.damage;
                        plant.hpBar.style.width = Math.max(0, (plant.hp / plant.maxHp) * 100) + '%';
                        if (plant.hp <= 0) {
                            plant.el.remove();
                            state.plants = state.plants.filter(p => p.id !== plant.id);
                            z.isEating = false; z.targetPlantId = null;
                        }
                    } else {
                        z.isEating = false; z.targetPlantId = null;
                    }
                } else {
                    z.x -= z.speed;
                    z.el.style.left = z.x + 'px';
                    const plantInFront = state.plants.find(p => p.row === z.row && Math.abs(z.x - (p.col * state.gridSize + 10)) < 30);
                    if (plantInFront) {
                        z.isEating = true; z.targetPlantId = plantInFront.id;
                    }
                    if (z.x < -40) {
                        handleGameOver('zombie');
                        return;
                    }
                }
            }
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>
